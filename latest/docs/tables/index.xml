<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Iceberg</title><link>https://samredai.github.io/iceberg-docs-prototype/latest/docs/tables/</link><description>Recent content on Apache Iceberg</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://samredai.github.io/iceberg-docs-prototype/latest/docs/tables/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://samredai.github.io/iceberg-docs-prototype/latest/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://samredai.github.io/iceberg-docs-prototype/latest/configuration/</guid><description>Configuration # Table properties # Iceberg tables support table properties to configure table behavior, like the default split size for readers.
Read properties # Property Default Description read.split.target-size 134217728 (128 MB) Target size when combining data input splits read.split.metadata-target-size 33554432 (32 MB) Target size when combining metadata input splits read.split.planning-lookback 10 Number of bins to consider when combining input splits read.</description></item><item><title/><link>https://samredai.github.io/iceberg-docs-prototype/latest/evolution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://samredai.github.io/iceberg-docs-prototype/latest/evolution/</guid><description>Evolution # Iceberg supports in-place table evolution. You can evolve a table schema just like SQL &amp;ndash; even in nested structures &amp;ndash; or change partition layout when data volume changes. Iceberg does not require costly distractions, like rewriting table data or migrating to a new table.
For example, Hive table partitioning cannot change so moving from a daily partition layout to an hourly partition layout requires a new table. And because queries are dependent on partitions, queries must be rewritten for the new table.</description></item><item><title/><link>https://samredai.github.io/iceberg-docs-prototype/latest/maintenance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://samredai.github.io/iceberg-docs-prototype/latest/maintenance/</guid><description>Maintenance # !!! Note Maintenance operations require the Table instance. Please refer Java API quickstart page to refer how to load an existing table.
Recommended Maintenance # Expire Snapshots # Each write to an Iceberg table creates a new snapshot, or version, of a table. Snapshots can be used for time-travel queries, or the table can be rolled back to any valid snapshot.
Snapshots accumulate until they are expired by the expireSnapshots operation.</description></item><item><title/><link>https://samredai.github.io/iceberg-docs-prototype/latest/partitioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://samredai.github.io/iceberg-docs-prototype/latest/partitioning/</guid><description>Partitioning # What is partitioning? # Partitioning is a way to make queries faster by grouping similar rows together when writing.
For example, queries for log entries from a logs table would usually include a time range, like this query for logs between 10 and 12 AM:
SELECT level, message FROM logs WHERE event_time BETWEEN &amp;#39;2018-12-01 10:00:00&amp;#39; AND &amp;#39;2018-12-01 12:00:00&amp;#39; Configuring the logs table to partition by the date of event_time will group log events into files with the same event date.</description></item><item><title/><link>https://samredai.github.io/iceberg-docs-prototype/latest/performance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://samredai.github.io/iceberg-docs-prototype/latest/performance/</guid><description>Performance # Iceberg is designed for huge tables and is used in production where a single table can contain tens of petabytes of data. Even multi-petabyte tables can be read from a single node, without needing a distributed SQL engine to sift through table metadata. Scan planning # Scan planning is the process of finding the files in a table that are needed for a query.</description></item><item><title/><link>https://samredai.github.io/iceberg-docs-prototype/latest/reliability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://samredai.github.io/iceberg-docs-prototype/latest/reliability/</guid><description>Reliability # Iceberg was designed to solve correctness problems that affect Hive tables running in S3.
Hive tables track data files using both a central metastore for partitions and a file system for individual files. This makes atomic changes to a table&amp;rsquo;s contents impossible, and eventually consistent stores like S3 may return incorrect results due to the use of listing files to reconstruct the state of a table. It also requires job planning to make many slow listing calls: O(n) with the number of partitions.</description></item><item><title/><link>https://samredai.github.io/iceberg-docs-prototype/latest/schemas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://samredai.github.io/iceberg-docs-prototype/latest/schemas/</guid><description>Schemas # Iceberg tables support the following types:
Type Description Notes boolean True or false int 32-bit signed integers Can promote to long long 64-bit signed integers float 32-bit IEEE 754 floating point Can promote to double double 64-bit IEEE 754 floating point decimal(P,S) Fixed-point decimal; precision P, scale S Scale is fixed and precision must be 38 or less date Calendar date without timezone or time time Time of day without date, timezone Stored as microseconds timestamp Timestamp without timezone Stored as microseconds timestamptz Timestamp with timezone Stored as microseconds string Arbitrary-length character sequences Encoded with UTF-8 fixed(L) Fixed-length byte array of length L binary Arbitrary-length byte array struct&amp;lt;.</description></item></channel></rss>